use std::lib::PredicateAddress;
use std::lib::@delta;
use std::lib::@safe_increment;
use std::lib::@init_once;
use std::lib::@init_delta;
use std::lib::@mut_keys;
use std::auth::@verify_key;
use std::lib::Secp256k1Signature;
use std::auth::@check_if_predicate_owns;

// -----------------------------------------------------------------------------
// types
// -----------------------------------------------------------------------------

union Resolution = Unresolved | Resolved(bool);

// -----------------------------------------------------------------------------
// storage
// -----------------------------------------------------------------------------

storage {
  user_balances: (b256 => int),
  user_nonces: (b256 => int),

  oracle_resolutions: (b256 => Resolution),
  oracle_nonces: (b256 => int),

  market_conditions: (b256 => PredicateAddress),
  market_resolutions: (b256 => Resolution),
  market_nonces: (b256 => int),
}

// -----------------------------------------------------------------------------
// predicates
// -----------------------------------------------------------------------------

predicate InitOracle {
  pub var key: b256;
  
  var sig: Secp256k1Signature;

  state nonce = mut storage::oracle_nonces[key];
  state resolution = mut storage::oracle_resolutions[key];

  constraint @init_once(nonce; 1);
  constraint @init_once(resolution; Resolution::Unresolved);

  // TODO: authorization
}

predicate ResolveOracle {
  pub var key: b256;
  pub var new_resolution: bool;

  state nonce = mut storage::oracle_nonces[key];
  state resolution = mut storage::oracle_resolutions[key];

  constraint nonce == 1;
  constraint nonce' == nonce + 1;
  constraint resolution' == Resolution::Resolved(new_resolution);
}

predicate CreateMarket {
  pub var key: b256;
  pub var cond_addr: PredicateAddress;

  state nonce = mut storage::market_nonces[key];
  state condition = mut storage::market_conditions[key];
  state resolution = mut storage::market_resolutions[key];

  constraint @init_once(nonce; 1);
  constraint @init_once(resolution; Resolution::Unresolved);
  constraint @init_once(condition; cond_addr);

  // TODO: let the market creator determine what the initial odds are
}

predicate BetMarket {}

predicate ResolveMarket {}

