use std::lib::PredicateAddress;
use std::lib::@delta;
use std::lib::@safe_increment;
use std::lib::@init_once;
use std::lib::@init_delta;
use std::lib::@mut_keys;
use std::auth::@verify_key;
use std::lib::Secp256k1Signature;
use std::auth::@check_if_predicate_owns;

// -----------------------------------------------------------------------------
// types
// -----------------------------------------------------------------------------

union Resolution = Unresolved | Resolved(bool);

union MarketCondition = Oracle(b256);

// -----------------------------------------------------------------------------
// storage
// -----------------------------------------------------------------------------

storage {
  user_balances: (b256 => int),
  user_nonces: (b256 => int),

  oracle_resolutions: (b256 => Resolution),
  oracle_nonces: (b256 => int),

  market_conditions: (b256 => MarketCondition),
  market_resolutions: (b256 => Resolution),
  market_nonces: (b256 => int),
}

// -----------------------------------------------------------------------------
// predicates
// -----------------------------------------------------------------------------

predicate InitOracle {
  pub var key: b256;
  
  var sig: Secp256k1Signature;

  state nonce = mut storage::oracle_nonces[key];
  state resolution = mut storage::oracle_resolutions[key];

  constraint @init_once(nonce; 1);
  constraint @init_once(resolution; Resolution::Unresolved);
  constraint @verify_key({key, nonce'}; sig; key);
}

predicate ResolveOracle {
  pub var key: b256;
  pub var new_resolution: bool;
  
  var sig: Secp256k1Signature;

  state nonce = mut storage::oracle_nonces[key];
  state resolution = mut storage::oracle_resolutions[key];

  constraint nonce == 1;
  constraint @safe_increment(nonce);
  constraint resolution' == Resolution::Resolved(new_resolution);
  constraint @verify_key({key, new_resolution, nonce'}; sig; key);
}

predicate InitMarket {
  pub var key: b256;
  pub var new_market_condition: MarketCondition;
  
  var sig: Secp256k1Signature;

  state nonce = mut storage::market_nonces[key];
  state market_condition = mut storage::market_conditions[key];
  state resolution = mut storage::market_resolutions[key];

  constraint @init_once(nonce; 1);
  constraint @init_once(resolution; Resolution::Unresolved);
  constraint @init_once(market_condition; new_market_condition);
  constraint @verify_key({key, new_market_condition, nonce'}; sig; key);
}

predicate BetMarket {}

predicate ResolveMarket {}

